# LFS ユーザーのパッケージ管理法

## 結論

10 年以上 LFS (Linux From Scratch) してきて /opt が一番向いていると思った。具体的には

- foo-1.1 が /opt/foo-1.1 に入っている。
- foo-1 が foo-1.1 にリンクしてある
- PATH+=/opt/foo-1/bin, ld.so.conf > /opt/foo-1/lib,
  PKG_CONFIG_PATH+=/opt/foo-1/lib/pkgconfig
- man 欲しければ MANPATH も
- foo-1.2 を /opt/foo-1.2 に入れた
- foo-1 を foo-1.2 のリンクにする

といった方法だ。最大のメリットは、新しいバージョン、オプション違い、CFLAGS 違いをすぐに切
り替えて試せること。安定して動くものを維持しておけること。動作保証の無い、LFS にはとてもマ
ッチする。

弱点は面倒なことだけど、LFS ユーザーが何を今更言うかという感じ。あとは PATH や
PKG_CONFIG_PATH が長くなってしまうことだけど、実用上問題ないし。

だけど問題もあって、良く知らないがビルド時のリンクの方が ld.so.conf よりも強いことがあり、
古いライブラリのパスを変えるとかしておかないと、使いたくないビルドが使い続けられてしまうこ
とがある。


## porg を使った /usr 集中管理の弱点

/usr で集中管理すると、PATH, PKG_CONFIG_PATH, /etc/ld.so.conf, MANPATH などは一切気にしな
くて良い。これは非常に魅力的だ。ただし、これは更新の時に既存のファイルを置き換えるので、

1. make でまともな実行ファイルができてなくても、例えば gcc-7.1 でビルドした firefox のよう
   に、成功扱いになった場合
2. make install の途中で libtool が何かに失敗した場合。

に困ったことになる。1 の場合、ちゃんと動くバージョンをビルドしなおす羽目になる。2 の場合も
1 と同じく、ちゃんと動くバージョンをビルドしなおす羽目になる。もっと困るのが、porg はエラ
ー扱いなので、porg を使ってインストールできてしまっている部分を削除できない。バージョン不
一致のライブラリのゴミなどが残るのだけど、これが不具合が起きたときに見つけるのが大変になる
。

## DESTDIR=/opt/hogehoge + graft での管理の問題点

これはなかなか便利で、バージョン違いやコンフィグオプション違いや CFLAGS 違いを試すのにもっ
てこい。ただし

1. DESTDIR に未対応のパッケージがある。
2. Python, Ruby などモジュールを追加するタイプのプログラムで新モジュールへのパスが書きかわ
   らないから手作業で設定しないとならない
3. graft コマンド自体も別に簡単なわけではない。

## 何かのパッケージ管理ツールを使って /usr に集中管理の問題点

Arch でビルドシステム使えば良くね？ (実際、次に PC 買ったら Arch に初挑戦するかもしれない)











<!-- vim: set tw=90 filetype=markdown : -->

